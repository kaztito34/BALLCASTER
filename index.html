<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Stack Tower ‚Äì Addictive HTML/JS</title>
<style>
  :root{
    --bg:#0c0b14; --panel:#17152a; --text:#f5f6ff; --accent:#7c5cff; --good:#00e2a3; --bad:#ff4c4c;
  }
  *{box-sizing:border-box}
  body{
    margin:0; background:linear-gradient(180deg,#0c0b14,#0a0a12 60%); color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu; display:grid; place-items:center; min-height:100vh;
  }
  .wrap{ width:min(480px,95vw); }
  .hud{
    display:flex; justify-content:space-between; align-items:center; gap:8px;
    background:var(--panel); border:1px solid rgba(255,255,255,.06); padding:10px 12px;
    border-radius:14px; margin:10px 0 8px; box-shadow:0 10px 30px rgba(0,0,0,.25);
  }
  .title{font-weight:800; letter-spacing:.5px}
  .score{font-weight:800}
  .best{opacity:.9; font-weight:700}
  .btn{
    background:var(--accent); border:0; color:#fff; font-weight:800; padding:10px 14px; border-radius:12px; cursor:pointer;
  }
  .btn:active{transform:translateY(1px)}
  canvas{
    width:100%; height:auto; display:block; border-radius:16px; border:1px solid rgba(255,255,255,.08);
    background: radial-gradient(120% 90% at 50% 0%, #1b1738 0%, #0e0c1f 60%);
    box-shadow:0 20px 60px rgba(0,0,0,.35);
  }
  .note{font-size:12px; opacity:.8; text-align:center; margin-top:8px}
  .toast{
    position:absolute; inset:0; display:grid; place-items:center; pointer-events:none;
    color:#fff; text-shadow:0 4px 18px rgba(0,0,0,.55);
    font-weight:900; font-size:clamp(20px,6vw,40px);
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="title">üèóÔ∏è Stack Tower</div>
      <div class="best">Best: <span id="best">0</span></div>
      <button id="restart" class="btn">Restart</button>
    </div>
    <div style="position:relative">
      <canvas id="game" width="480" height="720"></canvas>
      <div id="toast" class="toast"></div>
    </div>
    <div class="note">Click / Tap ŸÑÿ•ÿ≥ŸÇÿßÿ∑ ÿßŸÑÿ®ŸÑŸàŸÉ. ÿ≠ÿßŸàŸÑ ÿ™ÿ±ŸÉŸëÿ®Ÿà ŸÖÿ∂ÿ®Ÿàÿ∑ ŸÅŸàŸÇ ÿßŸÑŸÑŸä ÿ™ÿ≠ÿ™. ŸÑŸà ÿÆÿ±ÿ¨ ÿ®ÿ≤ÿßŸÅ: Game Over.</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const restartBtn = document.getElementById('restart');
  const toast = document.getElementById('toast');
  const bestEl = document.getElementById('best');

  // ------- Game config -------
  const H = canvas.height, W = canvas.width;
  const BLOCK_H = 26;
  const START_W = 220;
  const SPEED_START = 2.2;
  const SPEED_ADD = 0.08;
  const MIN_W = 20;
  const PERFECT_TOL = 6; // px
  const COLORS = ["#7c5cff","#22d3ee","#f59e0b","#10b981","#e879f9","#ef4444","#60a5fa","#a3e635"];

  // ------- State -------
  let blocks = []; // {x,w,y,dir,speed,color,stopped}
  let curr = null; // moving block (index)
  let baseY = H - 80; // top of base block
  let viewOffset = 0; // camera offset
  let score = 0;
  let best = Number(localStorage.getItem('stack_best')||0);
  bestEl.textContent = best;
  let over = false, started = false, shaking = 0;
  let combo = 0;
  let particles = [];

  function rand(a,b){ return Math.random()*(b-a)+a; }
  function lerp(a,b,t){ return a+(b-a)*t; }
  function clamp(x,a,b){ return Math.max(a,Math.min(b,x)); }

  function colorAt(i){
    // small gradient across blocks
    const t = (i%COLORS.length)/COLORS.length;
    const c1 = COLORS[i%COLORS.length];
    const c2 = COLORS[(i+1)%COLORS.length];
    return mixHex(c1,c2, (i*0.17)%1 );
  }
  function mixHex(h1,h2,t){
    const a = hexToRgb(h1), b = hexToRgb(h2);
    const r = Math.round(lerp(a.r,b.r,t)), g=Math.round(lerp(a.g,b.g,t)), bl=Math.round(lerp(a.b,b.b,t));
    return `rgb(${r},${g},${bl})`;
  }
  function hexToRgb(h){ const n=parseInt(h.slice(1),16); return {r:n>>16 & 255, g:n>>8&255, b:n&255}; }

  function reset(){
    blocks = [];
    particles = [];
    over = false; started = false; shaking = 0; combo = 0;
    viewOffset = 0; score = 0;
    // base block
    const base = { x: (W-START_W)/2, w: START_W, y: baseY, dir: 0, speed: 0, color: colorAt(0), stopped: true };
    blocks.push(base);
    spawnNext();
    draw(); // initial frame
  }

  function spawnNext(){
    const last = blocks[blocks.length-1];
    const fromLeft = (blocks.length % 2)===0;
    const w = last.w; // start same width; it‚Äôll get trimmed on drop
    const x = fromLeft ? -w : W;
    const dir = fromLeft ? 1 : -1;
    const speed = SPEED_START + (blocks.length-1)*SPEED_ADD;
    const y = last.y - BLOCK_H; // above last
    const color = colorAt(blocks.length);
    const b = { x, w, y, dir, speed, color, stopped: false };
    blocks.push(b);
    curr = blocks.length-1;

    // Camera: keep current near mid-height
    const target = H*0.55;
    const screenY = y - viewOffset;
    if (screenY < target) {
      const dy = target - screenY;
      viewOffset -= dy;
    }
  }

  function dropCurrent(){
    if (over || curr==null) return;
    const b = blocks[curr];
    b.stopped = true;

    const last = blocks[curr-1];
    // overlap with last
    const left = Math.max(b.x, last.x);
    const right = Math.min(b.x+b.w, last.x+last.w);
    const overlap = right - left;

    if (overlap <= 0 || b.w <= MIN_W) {
      gameOver();
      return;
    }

    // Perfect?
    const offset = Math.abs((b.x) - (last.x));
    if (offset <= PERFECT_TOL) {
      combo++;
      floatText("PERFECT!", b.x+b.w/2, b.y-20, "#00e2a3");
      // small forgiveness: expand tiny bit up to last width
      const gain = Math.min(8, last.w - b.w);
      b.x = last.x; b.w = clamp(b.w+gain, MIN_W, last.w);
      // confetti
      burst(b.x + b.w/2, b.y, b.color);
    } else {
      combo = 0;
      // Trim misaligned part
      b.x = left; b.w = overlap;
      // debris particles
      burst(left, b.y, "#ff7b7b", 10);
      shaking = 6;
    }

    score++;
    if (score>best){ best=score; localStorage.setItem('stack_best', best); bestEl.textContent = best; }

    // Spawn next
    spawnNext();
  }

  function floatText(t,x,y,color="#fff"){
    particles.push({type:"text", t:0, life:60, x, y, vx:0, vy:-0.4, text:t, color});
  }
  function burst(x,y,color,count=18){
    for(let i=0;i<count;i++){
      const a = rand(0,Math.PI*2), sp = rand(1,3);
      particles.push({type:"p", t:0, life:50, x, y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp-1, color, size: rand(2,4) });
    }
  }

  function gameOver(){
    over = true;
    floatText("GAME OVER", W/2, blocks[curr].y-40, "#ff5b5b");
    toast.textContent = "üí• GAME OVER";
    setTimeout(()=> toast.textContent="", 1200);
    shaking = 8;
  }

  function update(){
    // move current
    if (!over && curr!=null){
      const b = blocks[curr];
      if (!b.stopped){
        b.x += b.speed * b.dir;
        if (b.dir>0 && b.x+b.w >= W) { b.dir = -1; b.x = W - b.w; }
        if (b.dir<0 && b.x <= 0)     { b.dir =  1; b.x = 0; }
      }
    }

    // slight camera follow upwards
    const currentY = blocks[curr]?.y ?? baseY;
    const targetScreen = H*0.55;
    const screenY = currentY - viewOffset;
    if (screenY < targetScreen-2) viewOffset -= (targetScreen - screenY)*0.1;

    // particles
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.t++;
      if (p.type==="p"){
        p.x += p.vx; p.y += p.vy; p.vy += 0.05;
        if (p.t>p.life) particles.splice(i,1);
      } else {
        p.x += p.vx; p.y += p.vy;
        if (p.t>p.life) particles.splice(i,1);
      }
    }

    // screen shake decay
    shaking = Math.max(0, shaking-0.3);
  }

  function draw(){
    requestAnimationFrame(draw);
    update();

    // background
    ctx.clearRect(0,0,W,H);
    // parallax glow
    const grd = ctx.createRadialGradient(W/2, 80, 20, W/2, 0, 400);
    grd.addColorStop(0, "rgba(255,255,255,.05)");
    grd.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);

    // apply shake
    const sx = shaking ? (Math.random()*2-1)*shaking : 0;
    const sy = shaking ? (Math.random()*2-1)*shaking : 0;
    ctx.save(); ctx.translate(sx, sy);

    // draw blocks
    for (let i=0;i<blocks.length;i++){
      const b = blocks[i];
      const y = b.y - viewOffset;
      // drop shadow
      ctx.fillStyle = "rgba(0,0,0,.25)";
      ctx.fillRect(b.x+3, y+4, b.w, BLOCK_H);
      // block
      ctx.fillStyle = b.color;
      roundRect(ctx, b.x, y, b.w, BLOCK_H, 6);
      ctx.fill();

      // top highlight
      ctx.fillStyle = "rgba(255,255,255,.08)";
      roundRect(ctx, b.x, y, b.w, 6, 6);
      ctx.fill();
    }

    // particles
    for (const p of particles){
      if (p.type==="p"){
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x- p.size/2, (p.y - viewOffset)- p.size/2, p.size, p.size);
      } else {
        ctx.fillStyle = p.color;
        ctx.font = "900 20px system-ui";
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(p.text, p.x, (p.y - viewOffset));
      }
    }

    ctx.restore();

    // UI score
    ctx.fillStyle = "rgba(255,255,255,.9)";
    ctx.font = "900 28px system-ui";
    ctx.textAlign = "center"; ctx.textBaseline = "top";
    ctx.fillText(score, W/2, 14);
  }

  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // -------- Input (mouse/touch/keyboard) --------
  function handlePress(){
    if (!started){ started = true; return; } // first click just starts
    dropCurrent();
  }
  window.addEventListener('pointerdown', handlePress);
  window.addEventListener('keydown', e => { if (e.code==="Space" || e.code==="Enter") handlePress(); });

  restartBtn.addEventListener('click', reset);

  // Boot
  reset();

})();
</script>
</body>
</html>
